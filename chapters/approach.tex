%!TEX root = ../thesis.tex

\chapter{Approach}
\label{ch:approach}

Before we can start implementing anything, there are a few lingering design choices we have to make.
In this chapter we discuss and analyse these, and try to give a rationale for why we made the choices that we did.

\section{Student Repository Access}

Since students do not have access to other students' repositories, they have no easy way of accessing their code.
This becomes a necessity when want to do co-student code review, as they must somehow be given access to the relevant pull request.
In this section we discuss possible solutions to overcome this problem.

\subsection{Possible Solutions}

A solution could be to use GitHub teams, a feature that would allow us to grant limited access to individual repositories.
When a student is assigned to review someone else's pull request, such a team can be created with read rights to the relevant repository.
Once the review is finished, we can either remove the team from the repository, remove the student from the team, or just delete the team altogether.
This solution does however have some unwanted side effects, which can be illustrated with the following scenario.

Imagine we have two students: A and B.
Student A is finished with a task from assignment1, and therefore gets a reviewer assigned.
Student B is assigned to review it, and is granted access by QuickFeed to student A's repository.
Student A is also diligent, and has already started working on assignment2.
In fact, student A has nearly completed assignment2.
Student B however, has not even started on assignment2, but because they can now access student A's assignments, they see how he/she did it.

As a consequence, using GitHub teams would mean that assignments can only be published after the deadline of the previous one is passed.
A prospect that would probably not be appealing to most teachers.

Another possible solution is to create a clone repository, containing only the relevant assignment. 
This way, any reviewing student will only have access to the assignment in question.
QuickFeed would create these repositories when needed, and then delete them once the review is complete.

Implementing this however seems highly complex, as there is a myriad of complications and problems that will have to be accounted for.
For one, QuickFeed must be expanded to handle, amongst other things, the following.

\begin{itemize}
    \item Creating clone repositories containing only the assignment that is relevant, and the accompanying pull request.
    \item Deleting these repositories when they are no longer needed.
    \item Associating actions on the original repository, with the new one.
    I.e. we must make sure that any relevant additions are transparent in both
    \item Account for all possible complications that may occur.
\end{itemize}

An implementation like this also assumes that only one review is required per assignment, when there could in fact be several.
If for example an assignment has three tasks, and therefore three related pull requests, how do we then create these clone repositories?
Would we create one per pull request?
This seems like a terrible approach, as the number of repositories created would me enormous in courses with many students and assignments.

Let us say that we, despite these challenges, managed to create a fully functional implementation of the above solution.
We now have to cope with the prospect of having further complexified the user experience.
Possibly so much so that the entire solution might be counter-productive.

\subsection{Limiting Scope to Group Repositories}

The two solutions proposed in the previous section either seem too complex, or somewhat suboptimal.
Instead of going through with one of them, a compromise was agreed on to limit the project scope to only group assignments.
This means that instead of students reviewing each other's code on regular assignments, they will only do so on group assignments.
Furthermore, students will also only review other group members' code.

As an example, we can imagine a group assignment with three different tasks.
A group of three students will create a pull request each to solve these tasks.
They are then each assigned, when appropriate, to review one of the other group members' pull request.

The benefit of this approach is that it avoids students needing access to other repositories all together.
We only need to manage student review within a local group scope, and not for an entire course.

One disadvantage is that teachers will have to more carefully plan out the tasks they create.
Say we have a group of four members, and a group repository with only three issues.
One of the issues will have to be shared by two of the group members.
If every issue is equally challenging to solve, it would put the other two members at a disadvantage.
It seems then that teachers should only create as many tasks as there are designated group members, or at least a multiple of that number.

Another consideration teachers will have to account for, is that they have to create tasks that are independent of each other.
If task A is dependent on task B being complete, a consequence would be group members potentially having to wait for each other.

\section{Creating Pull Requests}

Having limited our approach to only group assignments in the previous section, we continue by discussing how to create the pull requests themselves.

There are two viable options, both with their own set of advantages and disadvantages.
Option one is to have students create the pull requests.
As issues are created on their group repository, the group members can internally decide who solves what issue.
Option two is having QuickFeed create the individual pull requests when tasks are created.

\subsection{Manual Creation}

An advantage of letting students manually create the pull requests, is that group members can self organize on who does what.
If a group member thinks a certain issue looks more interesting than the others, they can explicitly communicate this with the rest of the group.

Manually creating a pull request also allow us to restore a working state, in case a student incorrectly merges it.
This could happen if the pull request has not been approved by a teacher.
The same process we use internally to create the pull request, can be used again to recreate it.
This approach is described in more depth in section. % TODO: Ref to PR creation part.

The major disadvantage to relying on students to create the pull requests, is the increased complexity that comes with it.
Students will have to learn how to create and merge them correctly, and when to do so.
If a student messes up, they must know how to fix any potential complications.
And if they do not, the teaching staff must have the capacity to assist them.

\subsection{Automatic Creation}

The clear advantage to having QuickFeed automatically create pull requests, is that we do not make the process more complex for students.
If the students are not involved, there is no opportunity for them to mess up.
This also alleviates the teachers, as they no longer need to assist in case something goes wrong.

There is however a disadvantage to this approach.
Given that QuickFeed relies on authenticating with GitHub using users specific access tokens, each pull request would have to be made either in a student or teacher's name.
Both of these options seem suboptimal.
Creating them as teachers seems illogical, as one teacher will then be the owner of a huge number of pull requests they do not interact with.
If we create them as students, we could do so for each individual group member.
This still leaves us with the issue of having to decide what group member to use when creating the pull request
If the number of issues in a repository does not align with the number of group members, what should happen?
Even if we solve these problems, we are still left with the fact that individual group members can no longer self organize when assigning issues.

It seems then that any solution must create "anonymous" pull requests, i.e pull requests that are not directly assigned to any student or teacher.
One way to do this could be to have a QuickFeed bot account.
This bot account would then be the user used to create all required pull requests 
There are however drawbacks to this approach as well.
To facilitate student co-review, we must have a reference to the student who "checked out" the pull request.
If we do not, we will have no way of knowing from which pool of group members to select a reviewer later on.
This is given the fact that a student should not be assigned to review their own pull request.

\subsection{Conclusion}

While option two seems ideal, there are a few key points that made us instead go with option one.
First of all, the current iteration of QuickFeed does not seem to fully support it, as we have no direct way to create anonymous pull requests.
Secondly, option one gives us a greater capacity to handle students incorrectly mergeing pull requests.

It is worth noting that these two approaches are not mutually exclusive, and QuickFeed could support both solutions at the same time.
In fact, the initial idea was to implement them both, and thus getting all their benefits.

\section{Issue Creation}

The previous discussion highlights another problem that has to be taken into consideration, and regards how we create issues.

As mentioned, for every task, an issue should be created on all group repositories in a course.
To create these issues, we will have to use the GitHub API.
And again, given that GitHub authenticates on a per user basis, these issues must be created in the name of either a student or teacher.

Like with the pull request problem, creating them as a teacher seems wrong.
However, creating issues as a student does not seem that problematic.
Within a group, we could simply have the first student in the group be the creator.
And unlike the pull request problem, where ownership was highly relevant, it does not matter, given our context, who is assigned as an issue owner.
The issues only serve as a source of information, and the only interaction we have with them is to create pull requests linked to them.

\section{Automated Student Feedback}

To facilitate automatic feedback on individual pull requests, the initial idea was to use GitHub workflows.
This was mainly due to the fact that workflows are already tightly integrated into the GitHub pull request user interface.
As students work on tasks, we imagined using workflows to display their received score, and potentially the test results themselves.

However, as we researched ways to implement this, it became apparent that workflows were not an optimal approach.
For one, to have GitHub register a workflow, a \textit{.yml} file describing it must be present on the repository.
These files would have to be created and pushed to \textit{tests}, and then pulled by every student.
The biggest problem however, is that GitHub does not support triggering workflows manually via API, and having them appear in a pull request.
Meaning that we can trigger workflows remotely, but they cannot be displayed within a pull request on the same trigger.

As a consequence we have to find potential alternate solutions.
These are discussed in detail in the following sections.

\subsection{GitHub Checks API}

Only works with GitHub apps.

\subsection{Pull request comments}

Seems like a bot account or something would be needed otherwise.
Can create the comments in each students name.

\subsection{Commit Status API}

\section{Feedback content}

Also what should this feedback consist of? Can look at the type of automatic feedback they receive in web interface.

\section{GitHub App}

Should discuss the need to be able identify as QuickFeed when performing many of the actions needed in the implementation.
These include creating issues, creating pull requests and if 