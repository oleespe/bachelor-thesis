%!TEX root = ../thesis.tex

\chapter{Implementation}
\label{ch:implementation}

\section{Introduction}

Text text

\subsection{Feature Overview}

To fully grasp what we need to implement, this section describes all the features we want to have QuickFeed support.

\textbf{Tasks and issues}

First of all we want QuickFeed to support teachers creating task markdown files within individual assignments.
As these are created and pushed to \textit{tests}, QuickFeed should create GitHub issues based on their contents in all group repositories.
Furthermore, when these task files are updated or deleted, their changes should be reflected in their respective issues.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.8]{photos/tests-repository-structure-tasks.PNG}
    \caption{Example of a tests repository with tasks}
    \label{fig:tests-repository-structure-tasks}
\end{figure}

\textbf{Pull Requests}

For every issue, group members are expected to solve them by creating a new branch and pull request.
QuickFeed should then support...
\begin{itemize}
    \item Returning automatic feedback every time a student pushes to a pull request.
    \item Automatically assigning appropriate reviewers when students get a passing score on their code.
    Specifically one teacher and one other group member.
    \item Correctly closing the pull request when a teacher approves it.
\end{itemize}

\section{Existing implementation}

An implementation has already been attempted for this project. % TODO: Ref here, and mention both names.
Before we can begin with a new one, we first have to decide which parts of it we want to use, and which to discard.
These parts are summarized in this section.

\subsection{SCM Expansion}
\label{sec:scm_expansion}

The SCM package has been expanded to support the following functions:

\begin{itemize}
    \item CreateIssue   - creates an issue on a repository.
    \item EditRepoIssue - edits an issue on a repository.
    \item GetRepoIssue  - retrieves an issue based on issue number and repository.
    \item GetRepoIssues - retrieves all issues from a repository.
\end{itemize}

CreateIssue and EditRepoIssue would prove useful, and are used with only minor adjustments to them.
The two other functions, centered around retrieving issues were not needed, but still used in earlier parts of the project when testing.

\subsection{Logic}

A lot of existing code was intended to handle the logic around managing tasks. 
In short, this code was meant to do determine when to create, edit or delete issues on GitHub.
The code did however not accomplish this in a functional manner.
This lead to the dilemma of whether to continue developing this faulty code, or simply start anew.
In the end, we decided that any attempt to fix the existing logic code would be more time consuming and confusing than simply starting fresh.

\subsection{Parsing Tasks}
\label{sec:parsing_tasks}

When a teacher pushes assignments to the \textit{tests} repository, QuickFeed will run the function UpdateFromTestsRepo.
In short, this function creates a local copy of the folder structure found in \textit{tests}, and uses it to create or update the data-record of every assignment.
Added as a part of this process, was code to also fetch all task markdown files in the repository, and use their contents to create a task data object.

To support this, all \textit{task-*.md} files are expected to conform to a standard format.
The first line should start with the character sequence "\# <task title>", followed by by two new line characters.
Any following text there after will be treated as the task body or description.

Using this format, the function newTask creates a task data object from any task file.

\lstinputlisting[caption={Function that creates a task object from markdown content}, language=Golang, firstline=25, lastline=40]{code/tasks.go}

Going forward, the general approach to parsing and creating tasks is left as it is, with only minor changes to the existing code.

\section{Managing Tasks and Issues}

Having looked at what existing code we decided to keep, we continue by exploring the part of the project that was implemented first; how to manage tasks and issues.

Moving forward in this chapter, we make the following distinction between found tasks/assignments, and existing tasks/assignments.
Found tasks and assignments are data objects created from the contents found within the \textit{tests} repository.
Existing tasks and assignments are data-objects based on data records that we retrieve from the database.

\subsection{Data Structures}

Two new messages are defined in the ag.proto file: \textbf{Task} and \textbf{Issue}.
These are used to generate the data structures that we use throughout the rest of the project.

\textbf{Task} is defined as follows:

\lstinputlisting[caption={Task message}, firstline=185, lastline=193]{code/ag.proto}

Every task is associated with one assignment via the \textit{assignmentID} field.

For an assignment, \textit{order} is a number used to determine the order in which it is represented in a course.
It is set by a teacher in the \textit{assignment.yml} file, which is described in section \ref{sec:quickfeed-repository-structure}.
When we create a new task, keeping track of the corresponding assignment order is useful.
It allows us to associate tasks and assignments without explicitly knowing the assignment ID, so long as our scope is limited to just a single course.
A feature that will prove necessary.

The \textit{name} field is used to associate tasks found in \textit{tests}, with the ones stored in the database.
If a task file with the name task-hello\_world.md is found within assignment1, then its corresponding name will be assignment1/hello\_world.
This name is set when the task itself is parsed, as described in section \ref{sec:parsing_tasks}.

\textbf{Issue} is defined as follows:

\lstinputlisting[caption={Issue message}, firstline=195, lastline=200]{code/ag.proto}

We see that every issue holds an association to the task that was used to create it, as well as the repository it was created on.

The \textit{issueNumber} field represents the issue number GitHub assigns the issue on its creation.

As it will become important in the next section, we will also mention that a modification was made to the existing message \textbf{Assignment}.

\lstinputlisting[caption={Assignment message}, firstline=168, lastline=183]{code/ag.proto}

On line 14 on the above code we see that the message has repeated tasks.
When we compile it, the resulting data structure can hold a list of tasks.

\subsection{Main Logic}

As mentioned in section \ref{sec:parsing_tasks}, UpdateFromTestsRepo is run when someone pushes to the \textit{tests} repository.
Since tasks and issues need to be synchronized every time this happens, all logic for doing so will happen here.

More specifically, we create the function handleTasks that manages all logic relating to tasks.
It is supplied with every found assignment, and their respective found tasks, as an argument.
The function itself is run at the end of UpdateFromTestsRepo.

\lstinputlisting[caption={The function handleTasks, responsible for all task related logic}, 
                language=Golang, label={code:handleTasks}, firstline=64, lastline=95]{code/tasks.go}

The logic contained in this function will be explained in the following sections.

\subsection{Synchronizing Tasks}

When teachers create, edit, and delete tasks, we must make sure that the same happens in QuickFeed's internal database.
To accomplish this, we create the database method SynchronizeAssignmentTasks.
This method is run at the start of handleTasks, and can be summarized in the following chart.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{photos/synchronize-tasks-flow-chart.png}
    \caption{Flow chart describing how tasks are synchronized}
    \label{fig:synchronize-tasks-flow-chart}
\end{figure}

To support this logic, SynchronizeAssignmentTasks utilizes Go's built in maps to map tasks by both assignment order and name.
Given that we are limited in scope to a single course, we can use this mapping to associate every existing task to their found counterpart.

\lstinputlisting[caption={Logic performed in SynchronizeAssignmentTasks}, 
                language=Golang, label={code:SynchronizeAssignmentTasks}, firstline=41, lastline=76]{code/gormdb_tasks.go}

SynchronizeAssignmentTasks also returns the tasks it has created or updated, which will be important when synchronizing issues.

\subsection{Synchronizing Issues}

When we synchronize issues we must make sure to synchronize not only the issues stored in the database, but also the GitHub issues themselves.

As mentioned, SynchronizeAssignmentTasks already determines which tasks have been created, updated or deleted.
In fact, when it detects that a task has been deleted, it deletes not only the task but all associated issue records, as seen on line 11 in code \ref{code:SynchronizeAssignmentTasks}.
Issue data records also never need to be updated, since they carry no other information than an issue number, which always remains static.
The only remaining database related synchronization for issues is therefore creating them.

The entire process of synchronizing issues happens on line 16 to 31 in handleTasks \ref{code:handleTasks}.
In short, we use the created and updated tasks returned by SynchronizeAssignmentTasks, as arguments in createIssues and updateIssues respectively.
These functions use the SCM functions described in section \ref{sec:scm_expansion}.
Then, by looping through every course group repository we create and update GitHub issues accordingly.
createIssues also returns a list of all the issues it created.
These are used at the end of the process to create issue database records.

It is worth mentioning that there is no description of how we delete GitHub issues in the above process.
To delete issues, we wanted to expand the SCM API to give it that capacity.
It turns out however, that GitHub's REST API does not support deleting issues.
An alternative could be to use GraphQL, a query language for API's, but instead we went for a simpler solution.
In place of deleting issues, they are closed, and their title and body are inserted with a statement indicating that the associated task has been deleted.

\section{Managing Pull Requests}

Having implemented support for tasks and issues, we must now do the same for pull requests.

\subsection{Pull Request Data Structure}

To manage pull requests we need a data structure to represent them.
For this purpose, the \textbf{PullRequest} message is created.

\lstinputlisting[caption={PullRequest message}, firstline=202, lastline=217]{code/ag.proto} % TODO: Need to check for changes when finished

% TODO: Describe this message, and why certain fields are needed.
% TODO: Describe why linking the issue is important, i.e. we can delete the issue data record, and the issue is closed on GitHub.

\subsection{Creating Pull Requests}

As students create pull requests to solve issues/tasks, we must make sure that a pull request record is created and stored internally to represent them.
Doing so allows us to keep track of which student is solving what task, who should be assigned to review the pull request, and more.
This section describes how this is implemented.

In section \ref{sec:creating-pull-requests} we decided on having students manually create pull requests.
To accommodate this feature, QuickFeed must react to the pull requests being opened.
Expanding QuickFeed to also handle pull request related webhooks, allows us to do just that.

Specifically, when a pull request is opened the handlePullRequestOpened function is run.
It will check if a pull request is legitimate, i.e it was created on a group repository and linked to the correct issue.
If successful, the function creates a new record to represent it, by using the data in the event payload, and then stores it in the database.

Associating a pull request to an issue requires that the student themselves explicitly do so.
GitHub allows you to link issues to pull requests on their creation, by inserting a reference to them in the pull request body.
Doing so, we thought that the linked issue would also be part of the webhook payload, however, this turned out to be incorrect.
Instead we have to parse the issue number from the pull request body itself, as shown below.
% TODO: Should get code from file instead, when everything has been finalized.
\begin{lstlisting}[caption={The getLinkedIssue function}, language=Golang]
func getLinkedIssue(body string) (uint64, error) {
	if count := strings.Count(body, "#"); count != 1 {
		return 0, errors.New("pull request body does not contain exactly one '#' character")
	}
	subStrings := strings.Split(body, "#")
	issueNumber, err := strconv.Atoi(subStrings[len(subStrings)-1])
	if err != nil {
		return 0, fmt.Errorf("failed to parse issue number from pull request body: %w", err)
	}
	return uint64(issueNumber), nil
}
\end{lstlisting}

This solution somewhat limits the possible contents of a pull request body.
For example, students must make sure only to use one "\#" character for the function to succeed.
This is further discussed in section .% TODO: Ref to relevant discussion section.

\subsection{Closing Pull Requests}

When students close and merge pull requests - ideally when they are supposed to - QuickFeed must also act accordingly.
Again, we use webhooks to listen to pull request closed events, and single out those that are relevant to QuickFeed.
Relevant in this context is any event for a pull request that already exist in QuickFeed's database, i.e they were created as part of the process described in the above section.
Events for pull requests that are closed, but not merged, can also be filtered out, as these constitute an incorrect close.
If students do happen to close pull requests like this, a working state can be restored by the student simply by reopening it.
QuickFeed doing nothing in these cases is therefore the simplest solution.

Assuming that the event is valid, there are two possible outcomes.
Either the pull request is approved, and it and its associated issue can safely be deleted from the database.
Or, it has been closed and merged by a student without being explicitly approved by a teacher.
If this happens, QuickFeed must have the capacity to restore a working state for the issue/task in question.
To handle these situations, QuickFeed deletes only the pull request and not the issue record.
This way, a student doing an incorrect merge can simply reopen the issue that was closed, and then create a new pull request to represent it.
Thereby restoring a working state with little QuickFeed involvement.

\section{Scoring Tasks}

To allow for both automatic and manual feedback, we need a way to score tasks.
Delivering automatic feedback requires us to do so solely on the tests associated with any given task.
Manual feedback on the other hand, needs some sort of task related score to determine when to assign reviewers.
Currently QuickFeed only tests and scores student code based on an assignment as a whole.
Having it do so on a per task basis therefore seems like a necessity to fulfill our goals.

QuickFeed's ci package is fundamentally designed to test assignments, therefore rewriting it to support tasks would be challenging.
Any solution might also not be backwards compatible.
To implement our features though, QuickFeed does not need to test task related code, only score it.
As such, we can instead complement the score package to support this functionality.

% TODO: Need to describe the following changes further, and use code samples
Doing so turned out to be pretty straight forward.
First, the score message described in section \ref{sec:the-score-package} is modified to also include a task name field.
Doing so, gives us a direct reference to the task a given score is associated with.
Furthermore, to support teachers adding task specific tests, two new variants of the existing Add and AddSub methods are created.
These allow teachers to specify the task name a test should be a part of.
Finally, to generate a total task specific score, QuickFeed simply sums over the scores that have that task's name.

With these changes, we can generate a score from 0 - 100 for specific tasks, just as is already possible for entire assignments.

\section{Manual Feedback}

Having implemented QuickFeed support for scoring tasks in the previous section, these features can now be used to facilitate manual review.
In short, our approach is to assign one student and teacher reviewer to a pull request once a passing score is reached.
This passing score limit is the same as the assignment score limit.

Checking whether a task is passed or not must done every time a student pushes to a group repository.
QuickFeed already has a function that handles these push events, and we can therefore manage all review assignment related logic there.

\subsection{Assigning Reviewers}

To handle pushes to non-default branches in group repositories we implemented the handleTaskPush function.
Its primary job is to attempt to find a pull request that is associated with a given branch push.
In the event payload, there is information about both the branch and the repository that was pushed to.
Using these, QuickFeed queries the database for the specific pull request that is associated with them.

If a pull request exists for the repository and remote branch, it is used to retrieve the task associated with it.
Doing so allows us to get the specific task name, which can then be used to retrieve the task specific total score.
Finally, if this score is greater than the score limit, the assignment process can begin.

Before assigning reviewers there are a few things that have to be accounted for.
First of, we need to make sure not to assign the same reviewers over and over.
To illustrate, we do not want one teacher to review every pull request in a course, with the rest of the teachers not being assigned to review anything.
Similarly, having one group member review every pull request within a group is also unwanted.
Secondly, the owner of a pull request must not be assigned as its reviewer.

To tackle the first problem, we use two maps, one for teachers and one for group members, to facilitate in-memory storage of every reviewer.
Specifically, these maps track the total amount of times every reviewer has been assigned to a pull request.
They are described as follows, and are as shown, in fact maps of maps.

\begin{lstlisting}[caption={Maps used to store review counts}, language=Golang, numbers=none]
teacherReviewCounter[courseID][userID]  = count
groupReviewCounter[groupID][userID]     = count
\end{lstlisting}

These are then used as arguments in the in the function getNextReviewer.
getNextReviewer's purpose is to find, amongst the supplied users, the one that has the least amount of total reviews, and then return said user.
By supplying it with all course teachers or group member, it finds the next eligible teacher or student reviewer respectively.
To tackle the second problem mentioned earlier, we make sure to to not include the pull request owner in the user list.
% TODO: Should get code from file instead, when everything has been finalized.
\begin{lstlisting}[caption={The getNextReviewer function}, language=Golang]
func getNextReviewer(ID uint64, users []*pb.User, reviewCounter map[uint64]map[uint64]int) (*pb.User, error) {
	if len(users) == 0 {
		return nil, errors.New("list of users is empty")
	}
	reviewerMap, ok := reviewCounter[ID]
	if !ok {
		// If a map does not exist for a given ID we create it,
		// and return the first user.
		reviewCounter[ID] = make(map[uint64]int)
		reviewCounter[ID][users[0].GetID()] = 1
		return users[0], nil
	}
	userWithLowestCount := users[0]
	lowestCount := reviewerMap[users[0].GetID()]
	for _, user := range users {
		count, ok := reviewerMap[user.GetID()]
		if !ok {
			// If the user is not present in the review map,
			// then they are returned as the next reviewer.
			reviewerMap[user.GetID()] = 1
			return user, nil
		}
		if count < lowestCount {
			userWithLowestCount = user
			lowestCount = count
		}
	}
	reviewerMap[userWithLowestCount.GetID()]++
	return userWithLowestCount, nil
}
\end{lstlisting}

In order to actually assign reviewers to a GitHub pull request, the SCM API is expanded with the function RequestReviewers.
It is supplied with the GitHub login usernames of the found reviewers.
If successful, the entire process is finished by updating the pull request stage to \textit{review}, signaling that it is now being reviewed.

\subsection{Approving Pull Requests}

Having described how reviewers are assigned to pull requests in the previous section, this section explores what happens when teachers approve them.

The function handlePullRequestReview handles everything related to pull request reviews.
It is triggered by pull request review related webhooks, and uses the accompanying payload to find the relevant pull request record.
If one exists, it attempts to find the user that posted the review.
The reason why the specific reviewer is needed, is because we must make sure that the review is from an actual teacher.
Otherwise, the group member that was assigned to review could also internally approve the pull request.
So, as long as the review is from a teacher, the pull request stage is updated to \textit{approved}, meaning that it can be safely merged.

\section{Automatic Feedback}

Not fully implemented yet.